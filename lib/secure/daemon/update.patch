#include <lib.h>
#include <daemons.h>

mapping EventsMap = ([]);
mixed *event_funs = ({});
int connect_warn;
string shiz = "\n---------------\n"+ 
"%^RED%^CRITICAL%^RESET%^: There was a problem with "+
"/secure/lib/connect.c . When the upgrade is complete "+
"you must log out and log back in to make sure the "+
"correct file is in place.\n---------------\n";

int check_function(string str){
    if(member_array(str,MASTER_D->GetEfuns()) != -1) return 1;
    return 0;
}

int make_empties(){
    string *removes = ({
            "/spells",
            "/psionics",
            "/trades",
            "/prayers",
            "/feats",
            });

    string *empties = ({
            "/cmds/hm",
            "/cmds/builders",
            "/secure/cmds/common",
            "/secure/save/postal",
            "/secure/save/binaries",
            "/secure/save/decre",
            "/secure/save/players",
            "/secure/save/letters",
            "/secure/save/backup",
            "/secure/save/creators",
            "/secure/save/suicide",
            "/secure/save/rid",
            "/secure/save/votes",
            "/secure/upgrades/txt",
            "/www/doc",
            "/www/logs",
            "/doc/lpc/advanced",
            "/doc/tmp",
            "/doc/help/avatars",
            "/doc/help/hm",
            "/doc/help/religion",
            "/doc/help/law",
            "/doc/faq",
            "/log/author_stats",
            "/log/suicides",
            "/realms/template/tmp",
            "/realms/template/log",
            "/realms/template/area/etc",
            "/realms/template/area/meals",
            "/realms/template/area/doors",
            "/domains/town/save",
            "/domains/town/virtual/forest",
            "/domains/town/virtual/sub",
            "/domains/town/virtual/surface",
            "/domains/default/save",
            "/domains/default/virtual/sky",
            "/domains/default/virtual/arena",
            "/domains/Ylsrim/save",
            "/domains/Ylsrim/virtual/desert",
            "/verbs/spells",
            "/verbs/undead",
            "/secure/log/intermud",
            "/secure/log/network",
            "/domains/default/save",
            "/domains/town/save",
            "/open",
            "/powers",
            "/powers/spells",
            "/powers/prayers",
            "/powers/feats",
            "/powers/psionics",
            "/powers/trades",
            "/secure/log",
            "/secure/log/adm",
            "/secure/log/bak",
            "/secure/log/intermud",
            "/secure/log/network",
    });

    foreach(string dir in empties){
        catch( mkdir(dir) );
    }
    foreach(string dir in removes){
        catch( rmdir(dir) );
    }
    return 1;
}

void deletes(){
    rm("/lib/vi.c");
    rm("/cmds/admins/mfinger.c");
    rm("/cmds/players/locate.c");
    rm("/cmds/players/hist.c");
    rm("/cmds/creators/last.c");
    rm("/cmds/players/newbie.c");
    rm("/secure/daemon/map.c");
    rm("/secure/cmds/creators/sed.c");
    rm("/cmds/creators/which.c");
    rm("/secure/sefun/base_name.c");
    rm("/secure/sefun/convert_name.c");
    rm("/secure/sefun/query_names.c");
    rm("/domains/campus/room/store2.c");
    rm("/domains/town/room/room.c");
    rm("/domains/default/obj/flow.c");
    rm("/secure/cmds/admins/coordset.c");
    rm("/secure/lib/mssp.h");
    if(directory_exists("/domains/default/vehicles") &&
      !directory_exists("/domains/default/vehicle"))
    catch( rename("/domains/default/vehicles",
                "/domains/default/vehicle") );
}

varargs static void eventUpdate(object whom){
    int err, reboot;
    object remote;
    string a,b;
    string cpw,spw;
    string *file_arr;
    string x = read_file("/secure/daemon/imc2.c");
    int y = sscanf(x,"%s#define IMC2_CLIENT_PW \"%s\"%s",a,cpw,b);
    string config_file = read_file("/secure/include/config.h");
    string newfile = read_file("/secure/daemon/update.blank");
    y = sscanf(x,"%s#define IMC2_SERVER_PW \"%s\"%s",a,spw,b);
    write_file("/secure/daemon/update.c",newfile,1);

    if(!cp("/secure/lib/connect.real","/secure/lib/connect.c")){
        connect_warn = 1;
        if(whom){ 
            tell_player(whom, shiz);
        }
    }

    if(sizeof(config_file)){

        if(!grepp(config_file, "CLASS_SELECTION"))
            config_file = append_line(config_file,"#define HUMANS_ONLY",
                    "#define CLASS_SELECTION          0");

        if(!grepp(config_file, "SEVERABLE_LIMBS"))
            config_file = append_line(config_file,"#define HUMANS_ONLY",
                    "#define SEVERABLE_LIMBS          1");

        if(!grepp(config_file, "MAX_CALL_OUTS"))
            config_file = append_line(config_file,"#define F_TERMINAL_COLOR",
                    "#define MAX_CALL_OUTS            500");

        if(!grepp(config_file, "REQUIRE_QUESTING"))
            config_file = append_line(config_file,"#define MAX_CALL_OUTS",
                    "#define REQUIRE_QUESTING         1");

        if(!grepp(config_file, "AUTO_ADVANCE"))
            config_file = append_line(config_file,"#define REQUIRE_QUESTING",
                    "#define AUTO_ADVANCE             0");

        config_file = replace_string(config_file,"WEB_SOURCE   ",
                "WEB_SOURCE_IP");
        config_file = replace_string(config_file,"149.152.218.102",
                "204.209.44.12");

        if(!grepp(config_file, "WEB_SOURCE_NAME"))
            config_file = append_line(config_file,"#define WEB_SOURCE_IP",
                    "#define WEB_SOURCE_NAME          \"lpmuds.net\"");

        if(!grepp(config_file, "MAX_INVENTORY_SIZE"))
            config_file = append_line(config_file,"#define AUTO_ADVANCE",
                    "#define MAX_INVENTORY_SIZE       2048");

        if(!grepp(config_file, "MAX_ATTACKS_PER_HB"))
            config_file = append_line(config_file,"#define MAX_INVENTORY_SIZE",
                    "#define MAX_ATTACKS_PER_HB       40");

        if(!grepp(config_file, "MEMUSE_SOFT_LIMIT"))
            config_file = append_line(config_file,"#define MAX_ATTACKS_PER_HB",
                    "#define MEMUSE_SOFT_LIMIT        0");

        if(!grepp(config_file, "MEMUSE_HARD_LIMIT"))
            config_file = append_line(config_file,"#define MEMUSE_SOFT_LIMIT",
                    "#define MEMUSE_HARD_LIMIT        0");

        if(!grepp(config_file, "MAX_USERS"))
            config_file = append_line(config_file,"#define MEMUSE_HARD_LIMIT",
                    "#define MAX_USERS                0");

        if(!grepp(config_file, "MIN_PERF"))
            config_file = append_line(config_file,"#define MAX_USERS",
                    "#define MIN_PERF                 400");

        else config_file = replace_line(read_file("/secure/include/config.h"),
            ({"#define MIN_PERF"}),"#define MIN_PERF                 400");

        if(!grepp(config_file, "MINIMAP"))
            config_file = append_line(config_file,"#define MIN_PERF",
                    "#define MINIMAP                  1");

        if(!grepp(config_file, "WIZMAP"))
            config_file = append_line(config_file,"#define MINIMAP",
                    "#define WIZMAP                   1");

        if(!grepp(config_file, "GRID"))
            config_file = append_line(config_file,"#define WIZMAP",
                    "#define GRID                     1");

        if(!grepp(config_file, "ENABLE_INSTANCES"))
            config_file = append_line(config_file,"#define GRID",
                    "#define ENABLE_INSTANCES         0");

        if(!grepp(config_file, "CED_DISABLED"))
            config_file = append_line(config_file,"#define ENABLE_INSTANCES",
                    "#define CED_DISABLED             1");

        write_file("/secure/include/config.h", config_file+"\n", 1);
    }

    call_out( (: make_empties :),0);
    call_out( (: deletes :),0);

    catch( (: reload(LIB_DAEMON,1,1) :) );
    catch( (: reload(EVENTS_D,0,1) :) );
    catch( (: EventsMap = EVENTS_D->GetEvents() :) );
    if(sizeof(EventsMap)){
        foreach(mixed key, mixed val in EventsMap){
            event_funs += ({ val["function"] });
        }
        if(member_array("ReadDir",event_funs) == -1)
            EVENTS_D->AddEvent("/secure/daemon/file","/secure/daemon/file","ReadDir",({ }),90000,1);
        if(member_array("ReadFuns",event_funs) == -1)
            EVENTS_D->AddEvent("/secure/daemon/function","/secure/daemon/function","ReadFuns",({ }),100000,1);
        if(member_array("RotateLogs",event_funs) == -1)
            EVENTS_D->AddEvent("/secure/daemon/log","/secure/daemon/log","RotateLogs",({ }),3600,1);
    }
    newfile = read_file("/secure/cfg/read.cfg");
    if(!grepp(newfile,"/domains/cave/")){
        newfile += "(/domains/cave/) ASSIST:CMDS:CAVE\n";
    }
    if(!grepp(newfile,"/secure/include/secrets")){
        newfile += "(/secure/include/secrets*) SECURE\n";
    }
    write_file("/secure/cfg/read.cfg",newfile,1);

    catch( reload("/secure/daemon/master",0,1) );
    catch( reload("/secure/sefun/arrays",0,1) );
    catch( reload("/secure/sefun/sefun",0,1) );

    catch( reload("/domains/default/room/stargate_lab.c",0,1));
    catch( reload("/domains/town/virtual/space/1,1,1",0,1));
    catch( reload("/domains/town/virtual/bottom/33,100000",0,1));
    catch( reload("/domains/Praxis/square.c",0,1));
    catch( reload("/domains/Ylsrim/room/tower",0,1));
    catch( reload("/domains/campus/room/slab",0,1));
    update(LIB_SAVE);
    update(LIB_CLEAN);
    update(LIB_DAEMON);
    update(RELOAD_D);

    err = catch( update(LIB_ARMOR) );
    tc("err: "+err);
    if(whom){
        tell_player(whom,"Update daemon finished.");
        if(err || !strsrch(mudlib_version(),"2.8")){
            tell_player(whom,"Reboot is MANDATORY and happening now.");
            catch(flush_messages());
            reboot = 1;
        }
        else if(query_os_type() == "windows" || uptime() < 240){             
            tell_player(whom,"Rebooting now is a good idea.");
        }
        else tell_player(whom,"Initiating warm boot.");
    }
    if(reboot) shutdown(-9);
    if(!err && query_os_type() != "windows"){
        RELOAD_D->WarmBoot();
    }
    if(connect_warn){
        CHAT_D->eventSendChannel("UPDATE_D", "admin", shiz);
    }
}

static void create() {
    object whom;
    catch( load_object("/secure/cmds/admins/removeraces")->cmd());
    catch( load_object("/secure/cmds/admins/addraces")->cmd());
    if(this_player()) whom = this_player();
    call_out((: eventUpdate :), 1, whom);
    if(whom){
        tell_player(whom,"Please stand by until you see the \"Update daemon finished.\" message.");
        tell_player(whom,"If you do not see it after a few seconds, you may need to restore "
                "your mud from backup.");
    }
}
